// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: manager.sql

package manager

import (
	"context"
	"database/sql"
	"encoding/json"
	"time"
)

const checkUserQuota = `-- name: CheckUserQuota :one
SELECT 
  uq.max_projects,
  COALESCE(p.project_count, 0) as current_projects,
  CASE 
    WHEN uq.max_projects = 0 THEN TRUE
    WHEN uq.max_projects IS NULL THEN TRUE
    ELSE COALESCE(p.project_count, 0) < uq.max_projects
  END as can_create_project
FROM user_quotas uq
LEFT JOIN (
  SELECT owner_user_id, COUNT(*) as project_count 
  FROM projects 
  WHERE owner_user_id = ? 
  GROUP BY owner_user_id
) p ON uq.user_id = p.owner_user_id
WHERE uq.user_id = ?
`

type CheckUserQuotaParams struct {
	OwnerUserID uint64 `json:"owner_user_id"`
	UserID      uint64 `json:"user_id"`
}

type CheckUserQuotaRow struct {
	MaxProjects      uint32      `json:"max_projects"`
	CurrentProjects  int64       `json:"current_projects"`
	CanCreateProject interface{} `json:"can_create_project"`
}

func (q *Queries) CheckUserQuota(ctx context.Context, arg CheckUserQuotaParams) (CheckUserQuotaRow, error) {
	row := q.queryRow(ctx, q.checkUserQuotaStmt, checkUserQuota, arg.OwnerUserID, arg.UserID)
	var i CheckUserQuotaRow
	err := row.Scan(&i.MaxProjects, &i.CurrentProjects, &i.CanCreateProject)
	return i, err
}

const countActiveAPIKeys = `-- name: CountActiveAPIKeys :one
SELECT COUNT(*) FROM project_api_keys WHERE project_id = ? AND active = TRUE
`

func (q *Queries) CountActiveAPIKeys(ctx context.Context, projectID uint64) (int64, error) {
	row := q.queryRow(ctx, q.countActiveAPIKeysStmt, countActiveAPIKeys, projectID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countIconsByStatus = `-- name: CountIconsByStatus :one
SELECT COUNT(*) FROM icons WHERE project_id = ? AND status = ?
`

type CountIconsByStatusParams struct {
	ProjectID uint64      `json:"project_id"`
	Status    IconsStatus `json:"status"`
}

func (q *Queries) CountIconsByStatus(ctx context.Context, arg CountIconsByStatusParams) (int64, error) {
	row := q.queryRow(ctx, q.countIconsByStatusStmt, countIconsByStatus, arg.ProjectID, arg.Status)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countItemsByResolution = `-- name: CountItemsByResolution :one
SELECT COUNT(*) FROM request_items WHERE request_id = ? AND resolution = ?
`

type CountItemsByResolutionParams struct {
	RequestID  uint64                 `json:"request_id"`
	Resolution RequestItemsResolution `json:"resolution"`
}

func (q *Queries) CountItemsByResolution(ctx context.Context, arg CountItemsByResolutionParams) (int64, error) {
	row := q.queryRow(ctx, q.countItemsByResolutionStmt, countItemsByResolution, arg.RequestID, arg.Resolution)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countProjectCollaborators = `-- name: CountProjectCollaborators :one
SELECT COUNT(*) FROM user_project_roles WHERE project_id = ?
`

func (q *Queries) CountProjectCollaborators(ctx context.Context, projectID uint64) (int64, error) {
	row := q.queryRow(ctx, q.countProjectCollaboratorsStmt, countProjectCollaborators, projectID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countProjectIcons = `-- name: CountProjectIcons :one
SELECT COUNT(*) FROM icons WHERE project_id = ?
`

func (q *Queries) CountProjectIcons(ctx context.Context, projectID uint64) (int64, error) {
	row := q.queryRow(ctx, q.countProjectIconsStmt, countProjectIcons, projectID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countProjectRequests = `-- name: CountProjectRequests :one
SELECT COUNT(*) FROM icon_requests WHERE project_id = ?
`

func (q *Queries) CountProjectRequests(ctx context.Context, projectID uint64) (int64, error) {
	row := q.queryRow(ctx, q.countProjectRequestsStmt, countProjectRequests, projectID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countProjectsByOwner = `-- name: CountProjectsByOwner :one
SELECT COUNT(*) FROM projects WHERE owner_user_id = ?
`

func (q *Queries) CountProjectsByOwner(ctx context.Context, ownerUserID uint64) (int64, error) {
	row := q.queryRow(ctx, q.countProjectsByOwnerStmt, countProjectsByOwner, ownerUserID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countProjectsByVisibility = `-- name: CountProjectsByVisibility :one
SELECT COUNT(*) FROM projects WHERE visibility = ?
`

func (q *Queries) CountProjectsByVisibility(ctx context.Context, visibility ProjectsVisibility) (int64, error) {
	row := q.queryRow(ctx, q.countProjectsByVisibilityStmt, countProjectsByVisibility, visibility)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countRequestItems = `-- name: CountRequestItems :one
SELECT COUNT(*) FROM request_items WHERE request_id = ?
`

func (q *Queries) CountRequestItems(ctx context.Context, requestID uint64) (int64, error) {
	row := q.queryRow(ctx, q.countRequestItemsStmt, countRequestItems, requestID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countRequestsByStatus = `-- name: CountRequestsByStatus :one
SELECT COUNT(*) FROM icon_requests WHERE project_id = ? AND status = ?
`

type CountRequestsByStatusParams struct {
	ProjectID uint64             `json:"project_id"`
	Status    IconRequestsStatus `json:"status"`
}

func (q *Queries) CountRequestsByStatus(ctx context.Context, arg CountRequestsByStatusParams) (int64, error) {
	row := q.queryRow(ctx, q.countRequestsByStatusStmt, countRequestsByStatus, arg.ProjectID, arg.Status)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createIcon = `-- name: CreateIcon :execresult

INSERT INTO icons (
  project_id, name, pkg, component_info, drawable, status, metadata
) VALUES (?, ?, ?, ?, ?, ?, ?)
`

type CreateIconParams struct {
	ProjectID     uint64         `json:"project_id"`
	Name          string         `json:"name"`
	Pkg           string         `json:"pkg"`
	ComponentInfo string         `json:"component_info"`
	Drawable      string         `json:"drawable"`
	Status        IconsStatus    `json:"status"`
	Metadata      sql.NullString `json:"metadata"`
}

// =============================================================================
// ICONS MANAGEMENT
// =============================================================================
func (q *Queries) CreateIcon(ctx context.Context, arg CreateIconParams) (sql.Result, error) {
	return q.exec(ctx, q.createIconStmt, createIcon,
		arg.ProjectID,
		arg.Name,
		arg.Pkg,
		arg.ComponentInfo,
		arg.Drawable,
		arg.Status,
		arg.Metadata,
	)
}

const createIconRequest = `-- name: CreateIconRequest :execresult

INSERT INTO icon_requests (
  project_id, requested_by_user_id, source, apps_json, archive_path
) VALUES (?, ?, ?, ?, ?)
`

type CreateIconRequestParams struct {
	ProjectID         uint64             `json:"project_id"`
	RequestedByUserID sql.NullInt64      `json:"requested_by_user_id"`
	Source            IconRequestsSource `json:"source"`
	AppsJson          json.RawMessage    `json:"apps_json"`
	ArchivePath       sql.NullString     `json:"archive_path"`
}

// =============================================================================
// ICON REQUESTS MANAGEMENT
// =============================================================================
func (q *Queries) CreateIconRequest(ctx context.Context, arg CreateIconRequestParams) (sql.Result, error) {
	return q.exec(ctx, q.createIconRequestStmt, createIconRequest,
		arg.ProjectID,
		arg.RequestedByUserID,
		arg.Source,
		arg.AppsJson,
		arg.ArchivePath,
	)
}

const createProject = `-- name: CreateProject :execresult

INSERT INTO projects (
  owner_user_id, name, slug, package_name, visibility, description
) VALUES (?, ?, ?, ?, ?, ?)
`

type CreateProjectParams struct {
	OwnerUserID uint64             `json:"owner_user_id"`
	Name        string             `json:"name"`
	Slug        string             `json:"slug"`
	PackageName sql.NullString     `json:"package_name"`
	Visibility  ProjectsVisibility `json:"visibility"`
	Description sql.NullString     `json:"description"`
}

// =============================================================================
// PROJECTS MANAGEMENT
// =============================================================================
func (q *Queries) CreateProject(ctx context.Context, arg CreateProjectParams) (sql.Result, error) {
	return q.exec(ctx, q.createProjectStmt, createProject,
		arg.OwnerUserID,
		arg.Name,
		arg.Slug,
		arg.PackageName,
		arg.Visibility,
		arg.Description,
	)
}

const createProjectAPIKey = `-- name: CreateProjectAPIKey :execresult

INSERT INTO project_api_keys (project_id, name, token_hash) VALUES (?, ?, ?)
`

type CreateProjectAPIKeyParams struct {
	ProjectID uint64 `json:"project_id"`
	Name      string `json:"name"`
	TokenHash string `json:"token_hash"`
}

// =============================================================================
// PROJECT API KEYS MANAGEMENT
// =============================================================================
func (q *Queries) CreateProjectAPIKey(ctx context.Context, arg CreateProjectAPIKeyParams) (sql.Result, error) {
	return q.exec(ctx, q.createProjectAPIKeyStmt, createProjectAPIKey, arg.ProjectID, arg.Name, arg.TokenHash)
}

const createRequestItem = `-- name: CreateRequestItem :execresult

INSERT INTO request_items (
  request_id, project_id, name, pkg, component_info, drawable
) VALUES (?, ?, ?, ?, ?, ?)
`

type CreateRequestItemParams struct {
	RequestID     uint64 `json:"request_id"`
	ProjectID     uint64 `json:"project_id"`
	Name          string `json:"name"`
	Pkg           string `json:"pkg"`
	ComponentInfo string `json:"component_info"`
	Drawable      string `json:"drawable"`
}

// =============================================================================
// REQUEST ITEMS MANAGEMENT
// =============================================================================
func (q *Queries) CreateRequestItem(ctx context.Context, arg CreateRequestItemParams) (sql.Result, error) {
	return q.exec(ctx, q.createRequestItemStmt, createRequestItem,
		arg.RequestID,
		arg.ProjectID,
		arg.Name,
		arg.Pkg,
		arg.ComponentInfo,
		arg.Drawable,
	)
}

const createUserProjectRole = `-- name: CreateUserProjectRole :execresult

INSERT INTO user_project_roles (user_id, project_id, role) VALUES (?, ?, ?)
`

type CreateUserProjectRoleParams struct {
	UserID    uint64               `json:"user_id"`
	ProjectID uint64               `json:"project_id"`
	Role      UserProjectRolesRole `json:"role"`
}

// =============================================================================
// USER PROJECT ROLES MANAGEMENT
// =============================================================================
func (q *Queries) CreateUserProjectRole(ctx context.Context, arg CreateUserProjectRoleParams) (sql.Result, error) {
	return q.exec(ctx, q.createUserProjectRoleStmt, createUserProjectRole, arg.UserID, arg.ProjectID, arg.Role)
}

const createUserQuota = `-- name: CreateUserQuota :execresult

INSERT INTO user_quotas (user_id, max_projects) VALUES (?, ?)
`

type CreateUserQuotaParams struct {
	UserID      uint64 `json:"user_id"`
	MaxProjects uint32 `json:"max_projects"`
}

// =============================================================================
// USER QUOTAS MANAGEMENT
// =============================================================================
func (q *Queries) CreateUserQuota(ctx context.Context, arg CreateUserQuotaParams) (sql.Result, error) {
	return q.exec(ctx, q.createUserQuotaStmt, createUserQuota, arg.UserID, arg.MaxProjects)
}

const deactivateAPIKey = `-- name: DeactivateAPIKey :exec
UPDATE project_api_keys SET 
  active = FALSE,
  updated_at = CURRENT_TIMESTAMP(6)
WHERE id = ? AND project_id = ?
`

type DeactivateAPIKeyParams struct {
	ID        uint64 `json:"id"`
	ProjectID uint64 `json:"project_id"`
}

func (q *Queries) DeactivateAPIKey(ctx context.Context, arg DeactivateAPIKeyParams) error {
	_, err := q.exec(ctx, q.deactivateAPIKeyStmt, deactivateAPIKey, arg.ID, arg.ProjectID)
	return err
}

const deleteAPIKey = `-- name: DeleteAPIKey :exec
DELETE FROM project_api_keys WHERE id = ? AND project_id = ?
`

type DeleteAPIKeyParams struct {
	ID        uint64 `json:"id"`
	ProjectID uint64 `json:"project_id"`
}

func (q *Queries) DeleteAPIKey(ctx context.Context, arg DeleteAPIKeyParams) error {
	_, err := q.exec(ctx, q.deleteAPIKeyStmt, deleteAPIKey, arg.ID, arg.ProjectID)
	return err
}

const deleteIcon = `-- name: DeleteIcon :exec
DELETE FROM icons WHERE id = ? AND project_id = ?
`

type DeleteIconParams struct {
	ID        uint64 `json:"id"`
	ProjectID uint64 `json:"project_id"`
}

func (q *Queries) DeleteIcon(ctx context.Context, arg DeleteIconParams) error {
	_, err := q.exec(ctx, q.deleteIconStmt, deleteIcon, arg.ID, arg.ProjectID)
	return err
}

const deleteIconRequest = `-- name: DeleteIconRequest :exec
DELETE FROM icon_requests WHERE id = ? AND project_id = ?
`

type DeleteIconRequestParams struct {
	ID        uint64 `json:"id"`
	ProjectID uint64 `json:"project_id"`
}

func (q *Queries) DeleteIconRequest(ctx context.Context, arg DeleteIconRequestParams) error {
	_, err := q.exec(ctx, q.deleteIconRequestStmt, deleteIconRequest, arg.ID, arg.ProjectID)
	return err
}

const deleteProject = `-- name: DeleteProject :exec
DELETE FROM projects WHERE id = ? AND owner_user_id = ?
`

type DeleteProjectParams struct {
	ID          uint64 `json:"id"`
	OwnerUserID uint64 `json:"owner_user_id"`
}

func (q *Queries) DeleteProject(ctx context.Context, arg DeleteProjectParams) error {
	_, err := q.exec(ctx, q.deleteProjectStmt, deleteProject, arg.ID, arg.OwnerUserID)
	return err
}

const deleteProjectAPIKeys = `-- name: DeleteProjectAPIKeys :exec
DELETE FROM project_api_keys WHERE project_id = ?
`

func (q *Queries) DeleteProjectAPIKeys(ctx context.Context, projectID uint64) error {
	_, err := q.exec(ctx, q.deleteProjectAPIKeysStmt, deleteProjectAPIKeys, projectID)
	return err
}

const deleteProjectCollaborators = `-- name: DeleteProjectCollaborators :exec
DELETE FROM user_project_roles WHERE project_id = ?
`

func (q *Queries) DeleteProjectCollaborators(ctx context.Context, projectID uint64) error {
	_, err := q.exec(ctx, q.deleteProjectCollaboratorsStmt, deleteProjectCollaborators, projectID)
	return err
}

const deleteProjectIcons = `-- name: DeleteProjectIcons :exec
DELETE FROM icons WHERE project_id = ?
`

func (q *Queries) DeleteProjectIcons(ctx context.Context, projectID uint64) error {
	_, err := q.exec(ctx, q.deleteProjectIconsStmt, deleteProjectIcons, projectID)
	return err
}

const deleteProjectRequestItems = `-- name: DeleteProjectRequestItems :exec
DELETE FROM request_items WHERE project_id = ?
`

func (q *Queries) DeleteProjectRequestItems(ctx context.Context, projectID uint64) error {
	_, err := q.exec(ctx, q.deleteProjectRequestItemsStmt, deleteProjectRequestItems, projectID)
	return err
}

const deleteProjectRequests = `-- name: DeleteProjectRequests :exec
DELETE FROM icon_requests WHERE project_id = ?
`

func (q *Queries) DeleteProjectRequests(ctx context.Context, projectID uint64) error {
	_, err := q.exec(ctx, q.deleteProjectRequestsStmt, deleteProjectRequests, projectID)
	return err
}

const deleteRequestItem = `-- name: DeleteRequestItem :exec
DELETE FROM request_items WHERE id = ? AND request_id = ?
`

type DeleteRequestItemParams struct {
	ID        uint64 `json:"id"`
	RequestID uint64 `json:"request_id"`
}

func (q *Queries) DeleteRequestItem(ctx context.Context, arg DeleteRequestItemParams) error {
	_, err := q.exec(ctx, q.deleteRequestItemStmt, deleteRequestItem, arg.ID, arg.RequestID)
	return err
}

const deleteRequestItems = `-- name: DeleteRequestItems :exec
DELETE FROM request_items WHERE request_id = ?
`

func (q *Queries) DeleteRequestItems(ctx context.Context, requestID uint64) error {
	_, err := q.exec(ctx, q.deleteRequestItemsStmt, deleteRequestItems, requestID)
	return err
}

const deleteUserProjectRole = `-- name: DeleteUserProjectRole :exec
DELETE FROM user_project_roles WHERE user_id = ? AND project_id = ?
`

type DeleteUserProjectRoleParams struct {
	UserID    uint64 `json:"user_id"`
	ProjectID uint64 `json:"project_id"`
}

func (q *Queries) DeleteUserProjectRole(ctx context.Context, arg DeleteUserProjectRoleParams) error {
	_, err := q.exec(ctx, q.deleteUserProjectRoleStmt, deleteUserProjectRole, arg.UserID, arg.ProjectID)
	return err
}

const deleteUserQuota = `-- name: DeleteUserQuota :exec
DELETE FROM user_quotas WHERE user_id = ?
`

func (q *Queries) DeleteUserQuota(ctx context.Context, userID uint64) error {
	_, err := q.exec(ctx, q.deleteUserQuotaStmt, deleteUserQuota, userID)
	return err
}

const getDuplicateIcons = `-- name: GetDuplicateIcons :many
SELECT 
  i1.id, i1.project_id, i1.name, i1.pkg, i1.component_info, i1.drawable, i1.status, i1.metadata, i1.created_at, i1.updated_at,
  i2.id as duplicate_id,
  i2.name as duplicate_name,
  i2.created_at as duplicate_created_at
FROM icons i1
JOIN icons i2 ON i1.component_info = i2.component_info 
  AND i1.project_id = i2.project_id 
  AND i1.id != i2.id
WHERE i1.project_id = ?
ORDER BY i1.component_info, i1.created_at ASC
`

type GetDuplicateIconsRow struct {
	ID                 uint64         `json:"id"`
	ProjectID          uint64         `json:"project_id"`
	Name               string         `json:"name"`
	Pkg                string         `json:"pkg"`
	ComponentInfo      string         `json:"component_info"`
	Drawable           string         `json:"drawable"`
	Status             IconsStatus    `json:"status"`
	Metadata           sql.NullString `json:"metadata"`
	CreatedAt          time.Time      `json:"created_at"`
	UpdatedAt          time.Time      `json:"updated_at"`
	DuplicateID        uint64         `json:"duplicate_id"`
	DuplicateName      string         `json:"duplicate_name"`
	DuplicateCreatedAt time.Time      `json:"duplicate_created_at"`
}

func (q *Queries) GetDuplicateIcons(ctx context.Context, projectID uint64) ([]GetDuplicateIconsRow, error) {
	rows, err := q.query(ctx, q.getDuplicateIconsStmt, getDuplicateIcons, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetDuplicateIconsRow{}
	for rows.Next() {
		var i GetDuplicateIconsRow
		if err := rows.Scan(
			&i.ID,
			&i.ProjectID,
			&i.Name,
			&i.Pkg,
			&i.ComponentInfo,
			&i.Drawable,
			&i.Status,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DuplicateID,
			&i.DuplicateName,
			&i.DuplicateCreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getIconByComponent = `-- name: GetIconByComponent :one
SELECT id, project_id, name, pkg, component_info, drawable, status, metadata, created_at, updated_at FROM icons WHERE project_id = ? AND component_info = ? LIMIT 1
`

type GetIconByComponentParams struct {
	ProjectID     uint64 `json:"project_id"`
	ComponentInfo string `json:"component_info"`
}

func (q *Queries) GetIconByComponent(ctx context.Context, arg GetIconByComponentParams) (Icon, error) {
	row := q.queryRow(ctx, q.getIconByComponentStmt, getIconByComponent, arg.ProjectID, arg.ComponentInfo)
	var i Icon
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.Name,
		&i.Pkg,
		&i.ComponentInfo,
		&i.Drawable,
		&i.Status,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getIconByID = `-- name: GetIconByID :one
SELECT id, project_id, name, pkg, component_info, drawable, status, metadata, created_at, updated_at FROM icons WHERE id = ? LIMIT 1
`

func (q *Queries) GetIconByID(ctx context.Context, id uint64) (Icon, error) {
	row := q.queryRow(ctx, q.getIconByIDStmt, getIconByID, id)
	var i Icon
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.Name,
		&i.Pkg,
		&i.ComponentInfo,
		&i.Drawable,
		&i.Status,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getIconRequestByID = `-- name: GetIconRequestByID :one
SELECT id, project_id, requested_by_user_id, source, apps_json, archive_path, status, message, created_at, updated_at FROM icon_requests WHERE id = ? LIMIT 1
`

func (q *Queries) GetIconRequestByID(ctx context.Context, id uint64) (IconRequest, error) {
	row := q.queryRow(ctx, q.getIconRequestByIDStmt, getIconRequestByID, id)
	var i IconRequest
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.RequestedByUserID,
		&i.Source,
		&i.AppsJson,
		&i.ArchivePath,
		&i.Status,
		&i.Message,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getIconRequestByIDAndProject = `-- name: GetIconRequestByIDAndProject :one
SELECT id, project_id, requested_by_user_id, source, apps_json, archive_path, status, message, created_at, updated_at FROM icon_requests WHERE id = ? AND project_id = ? LIMIT 1
`

type GetIconRequestByIDAndProjectParams struct {
	ID        uint64 `json:"id"`
	ProjectID uint64 `json:"project_id"`
}

func (q *Queries) GetIconRequestByIDAndProject(ctx context.Context, arg GetIconRequestByIDAndProjectParams) (IconRequest, error) {
	row := q.queryRow(ctx, q.getIconRequestByIDAndProjectStmt, getIconRequestByIDAndProject, arg.ID, arg.ProjectID)
	var i IconRequest
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.RequestedByUserID,
		&i.Source,
		&i.AppsJson,
		&i.ArchivePath,
		&i.Status,
		&i.Message,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getIconStats = `-- name: GetIconStats :one
SELECT 
  COUNT(*) as total_icons,
  COUNT(CASE WHEN status = 'pending' THEN 1 END) as pending_count,
  COUNT(CASE WHEN status = 'in_progress' THEN 1 END) as in_progress_count,
  COUNT(CASE WHEN status = 'published' THEN 1 END) as published_count,
  COUNT(CASE WHEN status = 'rejected' THEN 1 END) as rejected_count
FROM icons 
WHERE project_id = ?
`

type GetIconStatsRow struct {
	TotalIcons      int64 `json:"total_icons"`
	PendingCount    int64 `json:"pending_count"`
	InProgressCount int64 `json:"in_progress_count"`
	PublishedCount  int64 `json:"published_count"`
	RejectedCount   int64 `json:"rejected_count"`
}

func (q *Queries) GetIconStats(ctx context.Context, projectID uint64) (GetIconStatsRow, error) {
	row := q.queryRow(ctx, q.getIconStatsStmt, getIconStats, projectID)
	var i GetIconStatsRow
	err := row.Scan(
		&i.TotalIcons,
		&i.PendingCount,
		&i.InProgressCount,
		&i.PublishedCount,
		&i.RejectedCount,
	)
	return i, err
}

const getIconWithRequestInfo = `-- name: GetIconWithRequestInfo :one
SELECT 
  i.id, i.project_id, i.name, i.pkg, i.component_info, i.drawable, i.status, i.metadata, i.created_at, i.updated_at,
  ri.request_id,
  ri.resolution as request_resolution,
  ri.notes as request_notes
FROM icons i
LEFT JOIN request_items ri ON i.id = ri.matched_icon_id
WHERE i.id = ?
`

type GetIconWithRequestInfoRow struct {
	ID                uint64                     `json:"id"`
	ProjectID         uint64                     `json:"project_id"`
	Name              string                     `json:"name"`
	Pkg               string                     `json:"pkg"`
	ComponentInfo     string                     `json:"component_info"`
	Drawable          string                     `json:"drawable"`
	Status            IconsStatus                `json:"status"`
	Metadata          sql.NullString             `json:"metadata"`
	CreatedAt         time.Time                  `json:"created_at"`
	UpdatedAt         time.Time                  `json:"updated_at"`
	RequestID         sql.NullInt64              `json:"request_id"`
	RequestResolution NullRequestItemsResolution `json:"request_resolution"`
	RequestNotes      sql.NullString             `json:"request_notes"`
}

func (q *Queries) GetIconWithRequestInfo(ctx context.Context, id uint64) (GetIconWithRequestInfoRow, error) {
	row := q.queryRow(ctx, q.getIconWithRequestInfoStmt, getIconWithRequestInfo, id)
	var i GetIconWithRequestInfoRow
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.Name,
		&i.Pkg,
		&i.ComponentInfo,
		&i.Drawable,
		&i.Status,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.RequestID,
		&i.RequestResolution,
		&i.RequestNotes,
	)
	return i, err
}

const getItemStats = `-- name: GetItemStats :one
SELECT 
  COUNT(*) as total_items,
  COUNT(CASE WHEN resolution = 'pending' THEN 1 END) as pending_count,
  COUNT(CASE WHEN resolution = 'created' THEN 1 END) as created_count,
  COUNT(CASE WHEN resolution = 'duplicate' THEN 1 END) as duplicate_count,
  COUNT(CASE WHEN resolution = 'rejected' THEN 1 END) as rejected_count
FROM request_items 
WHERE request_id = ?
`

type GetItemStatsRow struct {
	TotalItems     int64 `json:"total_items"`
	PendingCount   int64 `json:"pending_count"`
	CreatedCount   int64 `json:"created_count"`
	DuplicateCount int64 `json:"duplicate_count"`
	RejectedCount  int64 `json:"rejected_count"`
}

func (q *Queries) GetItemStats(ctx context.Context, requestID uint64) (GetItemStatsRow, error) {
	row := q.queryRow(ctx, q.getItemStatsStmt, getItemStats, requestID)
	var i GetItemStatsRow
	err := row.Scan(
		&i.TotalItems,
		&i.PendingCount,
		&i.CreatedCount,
		&i.DuplicateCount,
		&i.RejectedCount,
	)
	return i, err
}

const getProjectAPIKeyByHash = `-- name: GetProjectAPIKeyByHash :one
SELECT id, project_id, name, token_hash, active, last_used_at, created_at FROM project_api_keys WHERE token_hash = ? AND active = TRUE LIMIT 1
`

func (q *Queries) GetProjectAPIKeyByHash(ctx context.Context, tokenHash string) (ProjectApiKey, error) {
	row := q.queryRow(ctx, q.getProjectAPIKeyByHashStmt, getProjectAPIKeyByHash, tokenHash)
	var i ProjectApiKey
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.Name,
		&i.TokenHash,
		&i.Active,
		&i.LastUsedAt,
		&i.CreatedAt,
	)
	return i, err
}

const getProjectAPIKeyByID = `-- name: GetProjectAPIKeyByID :one
SELECT id, project_id, name, token_hash, active, last_used_at, created_at FROM project_api_keys WHERE id = ? LIMIT 1
`

func (q *Queries) GetProjectAPIKeyByID(ctx context.Context, id uint64) (ProjectApiKey, error) {
	row := q.queryRow(ctx, q.getProjectAPIKeyByIDStmt, getProjectAPIKeyByID, id)
	var i ProjectApiKey
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.Name,
		&i.TokenHash,
		&i.Active,
		&i.LastUsedAt,
		&i.CreatedAt,
	)
	return i, err
}

const getProjectByID = `-- name: GetProjectByID :one
SELECT id, owner_user_id, name, slug, package_name, visibility, description, icon_count, created_at, updated_at FROM projects WHERE id = ? LIMIT 1
`

func (q *Queries) GetProjectByID(ctx context.Context, id uint64) (Project, error) {
	row := q.queryRow(ctx, q.getProjectByIDStmt, getProjectByID, id)
	var i Project
	err := row.Scan(
		&i.ID,
		&i.OwnerUserID,
		&i.Name,
		&i.Slug,
		&i.PackageName,
		&i.Visibility,
		&i.Description,
		&i.IconCount,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getProjectByIDAndOwner = `-- name: GetProjectByIDAndOwner :one
SELECT id, owner_user_id, name, slug, package_name, visibility, description, icon_count, created_at, updated_at FROM projects WHERE id = ? AND owner_user_id = ? LIMIT 1
`

type GetProjectByIDAndOwnerParams struct {
	ID          uint64 `json:"id"`
	OwnerUserID uint64 `json:"owner_user_id"`
}

func (q *Queries) GetProjectByIDAndOwner(ctx context.Context, arg GetProjectByIDAndOwnerParams) (Project, error) {
	row := q.queryRow(ctx, q.getProjectByIDAndOwnerStmt, getProjectByIDAndOwner, arg.ID, arg.OwnerUserID)
	var i Project
	err := row.Scan(
		&i.ID,
		&i.OwnerUserID,
		&i.Name,
		&i.Slug,
		&i.PackageName,
		&i.Visibility,
		&i.Description,
		&i.IconCount,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getProjectBySlug = `-- name: GetProjectBySlug :one
SELECT id, owner_user_id, name, slug, package_name, visibility, description, icon_count, created_at, updated_at FROM projects WHERE owner_user_id = ? AND slug = ? LIMIT 1
`

type GetProjectBySlugParams struct {
	OwnerUserID uint64 `json:"owner_user_id"`
	Slug        string `json:"slug"`
}

func (q *Queries) GetProjectBySlug(ctx context.Context, arg GetProjectBySlugParams) (Project, error) {
	row := q.queryRow(ctx, q.getProjectBySlugStmt, getProjectBySlug, arg.OwnerUserID, arg.Slug)
	var i Project
	err := row.Scan(
		&i.ID,
		&i.OwnerUserID,
		&i.Name,
		&i.Slug,
		&i.PackageName,
		&i.Visibility,
		&i.Description,
		&i.IconCount,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getProjectStats = `-- name: GetProjectStats :one
SELECT 
  COUNT(*) as total_projects,
  SUM(icon_count) as total_icons,
  AVG(icon_count) as avg_icons_per_project
FROM projects 
WHERE owner_user_id = ?
`

type GetProjectStatsRow struct {
	TotalProjects      int64       `json:"total_projects"`
	TotalIcons         interface{} `json:"total_icons"`
	AvgIconsPerProject interface{} `json:"avg_icons_per_project"`
}

func (q *Queries) GetProjectStats(ctx context.Context, ownerUserID uint64) (GetProjectStatsRow, error) {
	row := q.queryRow(ctx, q.getProjectStatsStmt, getProjectStats, ownerUserID)
	var i GetProjectStatsRow
	err := row.Scan(&i.TotalProjects, &i.TotalIcons, &i.AvgIconsPerProject)
	return i, err
}

const getProjectWithStats = `-- name: GetProjectWithStats :one

SELECT 
  p.id, p.owner_user_id, p.name, p.slug, p.package_name, p.visibility, p.description, p.icon_count, p.created_at, p.updated_at,
  COALESCE(icon_stats.total_icons, 0) as total_icons,
  COALESCE(icon_stats.published_icons, 0) as published_icons,
  COALESCE(request_stats.total_requests, 0) as total_requests,
  COALESCE(collaborator_stats.collaborator_count, 0) as collaborator_count
FROM projects p
LEFT JOIN (
  SELECT 
    project_id,
    COUNT(*) as total_icons,
    COUNT(CASE WHEN status = 'published' THEN 1 END) as published_icons
  FROM icons 
  GROUP BY project_id
) icon_stats ON p.id = icon_stats.project_id
LEFT JOIN (
  SELECT 
    project_id,
    COUNT(*) as total_requests
  FROM icon_requests 
  GROUP BY project_id
) request_stats ON p.id = request_stats.project_id
LEFT JOIN (
  SELECT 
    project_id,
    COUNT(*) as collaborator_count
  FROM user_project_roles 
  GROUP BY project_id
) collaborator_stats ON p.id = collaborator_stats.project_id
WHERE p.id = ?
`

type GetProjectWithStatsRow struct {
	ID                uint64             `json:"id"`
	OwnerUserID       uint64             `json:"owner_user_id"`
	Name              string             `json:"name"`
	Slug              string             `json:"slug"`
	PackageName       sql.NullString     `json:"package_name"`
	Visibility        ProjectsVisibility `json:"visibility"`
	Description       sql.NullString     `json:"description"`
	IconCount         uint32             `json:"icon_count"`
	CreatedAt         time.Time          `json:"created_at"`
	UpdatedAt         time.Time          `json:"updated_at"`
	TotalIcons        int64              `json:"total_icons"`
	PublishedIcons    int64              `json:"published_icons"`
	TotalRequests     int64              `json:"total_requests"`
	CollaboratorCount int64              `json:"collaborator_count"`
}

// =============================================================================
// COMPLEX QUERIES AND JOINS
// =============================================================================
func (q *Queries) GetProjectWithStats(ctx context.Context, id uint64) (GetProjectWithStatsRow, error) {
	row := q.queryRow(ctx, q.getProjectWithStatsStmt, getProjectWithStats, id)
	var i GetProjectWithStatsRow
	err := row.Scan(
		&i.ID,
		&i.OwnerUserID,
		&i.Name,
		&i.Slug,
		&i.PackageName,
		&i.Visibility,
		&i.Description,
		&i.IconCount,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.TotalIcons,
		&i.PublishedIcons,
		&i.TotalRequests,
		&i.CollaboratorCount,
	)
	return i, err
}

const getRequestItemByComponent = `-- name: GetRequestItemByComponent :one
SELECT id, request_id, project_id, name, pkg, component_info, drawable, matched_icon_id, resolution, notes, created_at, updated_at FROM request_items WHERE request_id = ? AND component_info = ? LIMIT 1
`

type GetRequestItemByComponentParams struct {
	RequestID     uint64 `json:"request_id"`
	ComponentInfo string `json:"component_info"`
}

func (q *Queries) GetRequestItemByComponent(ctx context.Context, arg GetRequestItemByComponentParams) (RequestItem, error) {
	row := q.queryRow(ctx, q.getRequestItemByComponentStmt, getRequestItemByComponent, arg.RequestID, arg.ComponentInfo)
	var i RequestItem
	err := row.Scan(
		&i.ID,
		&i.RequestID,
		&i.ProjectID,
		&i.Name,
		&i.Pkg,
		&i.ComponentInfo,
		&i.Drawable,
		&i.MatchedIconID,
		&i.Resolution,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getRequestItemByID = `-- name: GetRequestItemByID :one
SELECT id, request_id, project_id, name, pkg, component_info, drawable, matched_icon_id, resolution, notes, created_at, updated_at FROM request_items WHERE id = ? LIMIT 1
`

func (q *Queries) GetRequestItemByID(ctx context.Context, id uint64) (RequestItem, error) {
	row := q.queryRow(ctx, q.getRequestItemByIDStmt, getRequestItemByID, id)
	var i RequestItem
	err := row.Scan(
		&i.ID,
		&i.RequestID,
		&i.ProjectID,
		&i.Name,
		&i.Pkg,
		&i.ComponentInfo,
		&i.Drawable,
		&i.MatchedIconID,
		&i.Resolution,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getRequestStats = `-- name: GetRequestStats :one
SELECT 
  COUNT(*) as total_requests,
  COUNT(CASE WHEN status = 'received' THEN 1 END) as received_count,
  COUNT(CASE WHEN status = 'processing' THEN 1 END) as processing_count,
  COUNT(CASE WHEN status = 'done' THEN 1 END) as done_count,
  COUNT(CASE WHEN status = 'failed' THEN 1 END) as failed_count
FROM icon_requests 
WHERE project_id = ?
`

type GetRequestStatsRow struct {
	TotalRequests   int64 `json:"total_requests"`
	ReceivedCount   int64 `json:"received_count"`
	ProcessingCount int64 `json:"processing_count"`
	DoneCount       int64 `json:"done_count"`
	FailedCount     int64 `json:"failed_count"`
}

func (q *Queries) GetRequestStats(ctx context.Context, projectID uint64) (GetRequestStatsRow, error) {
	row := q.queryRow(ctx, q.getRequestStatsStmt, getRequestStats, projectID)
	var i GetRequestStatsRow
	err := row.Scan(
		&i.TotalRequests,
		&i.ReceivedCount,
		&i.ProcessingCount,
		&i.DoneCount,
		&i.FailedCount,
	)
	return i, err
}

const getUserProjectRole = `-- name: GetUserProjectRole :one
SELECT user_id, project_id, role, added_at FROM user_project_roles WHERE user_id = ? AND project_id = ? LIMIT 1
`

type GetUserProjectRoleParams struct {
	UserID    uint64 `json:"user_id"`
	ProjectID uint64 `json:"project_id"`
}

func (q *Queries) GetUserProjectRole(ctx context.Context, arg GetUserProjectRoleParams) (UserProjectRole, error) {
	row := q.queryRow(ctx, q.getUserProjectRoleStmt, getUserProjectRole, arg.UserID, arg.ProjectID)
	var i UserProjectRole
	err := row.Scan(
		&i.UserID,
		&i.ProjectID,
		&i.Role,
		&i.AddedAt,
	)
	return i, err
}

const getUserQuota = `-- name: GetUserQuota :one
SELECT user_id, max_projects, created_at FROM user_quotas WHERE user_id = ? LIMIT 1
`

func (q *Queries) GetUserQuota(ctx context.Context, userID uint64) (UserQuota, error) {
	row := q.queryRow(ctx, q.getUserQuotaStmt, getUserQuota, userID)
	var i UserQuota
	err := row.Scan(&i.UserID, &i.MaxProjects, &i.CreatedAt)
	return i, err
}

const listIconsByPackage = `-- name: ListIconsByPackage :many
SELECT id, project_id, name, pkg, component_info, drawable, status, metadata, created_at, updated_at FROM icons WHERE project_id = ? AND pkg = ? ORDER BY name ASC
`

type ListIconsByPackageParams struct {
	ProjectID uint64 `json:"project_id"`
	Pkg       string `json:"pkg"`
}

func (q *Queries) ListIconsByPackage(ctx context.Context, arg ListIconsByPackageParams) ([]Icon, error) {
	rows, err := q.query(ctx, q.listIconsByPackageStmt, listIconsByPackage, arg.ProjectID, arg.Pkg)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Icon{}
	for rows.Next() {
		var i Icon
		if err := rows.Scan(
			&i.ID,
			&i.ProjectID,
			&i.Name,
			&i.Pkg,
			&i.ComponentInfo,
			&i.Drawable,
			&i.Status,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listIconsByStatus = `-- name: ListIconsByStatus :many
SELECT id, project_id, name, pkg, component_info, drawable, status, metadata, created_at, updated_at FROM icons WHERE project_id = ? AND status = ? ORDER BY created_at DESC LIMIT ? OFFSET ?
`

type ListIconsByStatusParams struct {
	ProjectID uint64      `json:"project_id"`
	Status    IconsStatus `json:"status"`
	Limit     int32       `json:"limit"`
	Offset    int32       `json:"offset"`
}

func (q *Queries) ListIconsByStatus(ctx context.Context, arg ListIconsByStatusParams) ([]Icon, error) {
	rows, err := q.query(ctx, q.listIconsByStatusStmt, listIconsByStatus,
		arg.ProjectID,
		arg.Status,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Icon{}
	for rows.Next() {
		var i Icon
		if err := rows.Scan(
			&i.ID,
			&i.ProjectID,
			&i.Name,
			&i.Pkg,
			&i.ComponentInfo,
			&i.Drawable,
			&i.Status,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listItemsByResolution = `-- name: ListItemsByResolution :many
SELECT id, request_id, project_id, name, pkg, component_info, drawable, matched_icon_id, resolution, notes, created_at, updated_at FROM request_items WHERE request_id = ? AND resolution = ? ORDER BY created_at ASC
`

type ListItemsByResolutionParams struct {
	RequestID  uint64                 `json:"request_id"`
	Resolution RequestItemsResolution `json:"resolution"`
}

func (q *Queries) ListItemsByResolution(ctx context.Context, arg ListItemsByResolutionParams) ([]RequestItem, error) {
	rows, err := q.query(ctx, q.listItemsByResolutionStmt, listItemsByResolution, arg.RequestID, arg.Resolution)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []RequestItem{}
	for rows.Next() {
		var i RequestItem
		if err := rows.Scan(
			&i.ID,
			&i.RequestID,
			&i.ProjectID,
			&i.Name,
			&i.Pkg,
			&i.ComponentInfo,
			&i.Drawable,
			&i.MatchedIconID,
			&i.Resolution,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProjectAPIKeys = `-- name: ListProjectAPIKeys :many
SELECT id, project_id, name, token_hash, active, last_used_at, created_at FROM project_api_keys WHERE project_id = ? ORDER BY created_at DESC
`

func (q *Queries) ListProjectAPIKeys(ctx context.Context, projectID uint64) ([]ProjectApiKey, error) {
	rows, err := q.query(ctx, q.listProjectAPIKeysStmt, listProjectAPIKeys, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ProjectApiKey{}
	for rows.Next() {
		var i ProjectApiKey
		if err := rows.Scan(
			&i.ID,
			&i.ProjectID,
			&i.Name,
			&i.TokenHash,
			&i.Active,
			&i.LastUsedAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProjectCollaborators = `-- name: ListProjectCollaborators :many
SELECT upr.user_id, upr.project_id, upr.role, upr.added_at, u.username, u.display_name, u.avatar_url
FROM user_project_roles upr
JOIN users u ON upr.user_id = u.id
WHERE upr.project_id = ?
ORDER BY upr.added_at ASC
`

type ListProjectCollaboratorsRow struct {
	UserID      uint64               `json:"user_id"`
	ProjectID   uint64               `json:"project_id"`
	Role        UserProjectRolesRole `json:"role"`
	AddedAt     time.Time            `json:"added_at"`
	Username    string               `json:"username"`
	DisplayName sql.NullString       `json:"display_name"`
	AvatarUrl   sql.NullString       `json:"avatar_url"`
}

func (q *Queries) ListProjectCollaborators(ctx context.Context, projectID uint64) ([]ListProjectCollaboratorsRow, error) {
	rows, err := q.query(ctx, q.listProjectCollaboratorsStmt, listProjectCollaborators, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListProjectCollaboratorsRow{}
	for rows.Next() {
		var i ListProjectCollaboratorsRow
		if err := rows.Scan(
			&i.UserID,
			&i.ProjectID,
			&i.Role,
			&i.AddedAt,
			&i.Username,
			&i.DisplayName,
			&i.AvatarUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProjectIcons = `-- name: ListProjectIcons :many
SELECT id, project_id, name, pkg, component_info, drawable, status, metadata, created_at, updated_at FROM icons WHERE project_id = ? ORDER BY created_at DESC LIMIT ? OFFSET ?
`

type ListProjectIconsParams struct {
	ProjectID uint64 `json:"project_id"`
	Limit     int32  `json:"limit"`
	Offset    int32  `json:"offset"`
}

func (q *Queries) ListProjectIcons(ctx context.Context, arg ListProjectIconsParams) ([]Icon, error) {
	rows, err := q.query(ctx, q.listProjectIconsStmt, listProjectIcons, arg.ProjectID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Icon{}
	for rows.Next() {
		var i Icon
		if err := rows.Scan(
			&i.ID,
			&i.ProjectID,
			&i.Name,
			&i.Pkg,
			&i.ComponentInfo,
			&i.Drawable,
			&i.Status,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProjectRequestItems = `-- name: ListProjectRequestItems :many
SELECT id, request_id, project_id, name, pkg, component_info, drawable, matched_icon_id, resolution, notes, created_at, updated_at FROM request_items WHERE project_id = ? ORDER BY created_at DESC LIMIT ? OFFSET ?
`

type ListProjectRequestItemsParams struct {
	ProjectID uint64 `json:"project_id"`
	Limit     int32  `json:"limit"`
	Offset    int32  `json:"offset"`
}

func (q *Queries) ListProjectRequestItems(ctx context.Context, arg ListProjectRequestItemsParams) ([]RequestItem, error) {
	rows, err := q.query(ctx, q.listProjectRequestItemsStmt, listProjectRequestItems, arg.ProjectID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []RequestItem{}
	for rows.Next() {
		var i RequestItem
		if err := rows.Scan(
			&i.ID,
			&i.RequestID,
			&i.ProjectID,
			&i.Name,
			&i.Pkg,
			&i.ComponentInfo,
			&i.Drawable,
			&i.MatchedIconID,
			&i.Resolution,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProjectRequests = `-- name: ListProjectRequests :many
SELECT id, project_id, requested_by_user_id, source, apps_json, archive_path, status, message, created_at, updated_at FROM icon_requests WHERE project_id = ? ORDER BY created_at DESC LIMIT ? OFFSET ?
`

type ListProjectRequestsParams struct {
	ProjectID uint64 `json:"project_id"`
	Limit     int32  `json:"limit"`
	Offset    int32  `json:"offset"`
}

func (q *Queries) ListProjectRequests(ctx context.Context, arg ListProjectRequestsParams) ([]IconRequest, error) {
	rows, err := q.query(ctx, q.listProjectRequestsStmt, listProjectRequests, arg.ProjectID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []IconRequest{}
	for rows.Next() {
		var i IconRequest
		if err := rows.Scan(
			&i.ID,
			&i.ProjectID,
			&i.RequestedByUserID,
			&i.Source,
			&i.AppsJson,
			&i.ArchivePath,
			&i.Status,
			&i.Message,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProjectsByOwner = `-- name: ListProjectsByOwner :many
SELECT id, owner_user_id, name, slug, package_name, visibility, description, icon_count, created_at, updated_at FROM projects WHERE owner_user_id = ? ORDER BY created_at DESC LIMIT ? OFFSET ?
`

type ListProjectsByOwnerParams struct {
	OwnerUserID uint64 `json:"owner_user_id"`
	Limit       int32  `json:"limit"`
	Offset      int32  `json:"offset"`
}

func (q *Queries) ListProjectsByOwner(ctx context.Context, arg ListProjectsByOwnerParams) ([]Project, error) {
	rows, err := q.query(ctx, q.listProjectsByOwnerStmt, listProjectsByOwner, arg.OwnerUserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Project{}
	for rows.Next() {
		var i Project
		if err := rows.Scan(
			&i.ID,
			&i.OwnerUserID,
			&i.Name,
			&i.Slug,
			&i.PackageName,
			&i.Visibility,
			&i.Description,
			&i.IconCount,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProjectsByVisibility = `-- name: ListProjectsByVisibility :many
SELECT id, owner_user_id, name, slug, package_name, visibility, description, icon_count, created_at, updated_at FROM projects WHERE visibility = ? ORDER BY created_at DESC LIMIT ? OFFSET ?
`

type ListProjectsByVisibilityParams struct {
	Visibility ProjectsVisibility `json:"visibility"`
	Limit      int32              `json:"limit"`
	Offset     int32              `json:"offset"`
}

func (q *Queries) ListProjectsByVisibility(ctx context.Context, arg ListProjectsByVisibilityParams) ([]Project, error) {
	rows, err := q.query(ctx, q.listProjectsByVisibilityStmt, listProjectsByVisibility, arg.Visibility, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Project{}
	for rows.Next() {
		var i Project
		if err := rows.Scan(
			&i.ID,
			&i.OwnerUserID,
			&i.Name,
			&i.Slug,
			&i.PackageName,
			&i.Visibility,
			&i.Description,
			&i.IconCount,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPublicProjects = `-- name: ListPublicProjects :many
SELECT id, owner_user_id, name, slug, package_name, visibility, description, icon_count, created_at, updated_at FROM projects WHERE visibility = 'public' ORDER BY created_at DESC LIMIT ? OFFSET ?
`

type ListPublicProjectsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListPublicProjects(ctx context.Context, arg ListPublicProjectsParams) ([]Project, error) {
	rows, err := q.query(ctx, q.listPublicProjectsStmt, listPublicProjects, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Project{}
	for rows.Next() {
		var i Project
		if err := rows.Scan(
			&i.ID,
			&i.OwnerUserID,
			&i.Name,
			&i.Slug,
			&i.PackageName,
			&i.Visibility,
			&i.Description,
			&i.IconCount,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRecentActivity = `-- name: ListRecentActivity :many
SELECT 
  'icon_request' as activity_type,
  ir.id as activity_id,
  ir.project_id,
  ir.status,
  ir.created_at,
  p.name as project_name,
  u.username as requested_by
FROM icon_requests ir
JOIN projects p ON ir.project_id = p.id
LEFT JOIN users u ON ir.requested_by_user_id = u.id
WHERE ir.project_id = ?
UNION ALL
SELECT 
  'icon_status_change' as activity_type,
  i.id as activity_id,
  i.project_id,
  i.status,
  i.updated_at as created_at,
  p.name as project_name,
  NULL as requested_by
FROM icons i
JOIN projects p ON i.project_id = p.id
WHERE i.project_id = ? AND i.updated_at > i.created_at
ORDER BY created_at DESC
LIMIT ? OFFSET ?
`

type ListRecentActivityParams struct {
	ProjectID   uint64 `json:"project_id"`
	ProjectID_2 uint64 `json:"project_id_2"`
	Limit       int32  `json:"limit"`
	Offset      int32  `json:"offset"`
}

type ListRecentActivityRow struct {
	ActivityType string             `json:"activity_type"`
	ActivityID   uint64             `json:"activity_id"`
	ProjectID    uint64             `json:"project_id"`
	Status       IconRequestsStatus `json:"status"`
	CreatedAt    time.Time          `json:"created_at"`
	ProjectName  string             `json:"project_name"`
	RequestedBy  sql.NullString     `json:"requested_by"`
}

func (q *Queries) ListRecentActivity(ctx context.Context, arg ListRecentActivityParams) ([]ListRecentActivityRow, error) {
	rows, err := q.query(ctx, q.listRecentActivityStmt, listRecentActivity,
		arg.ProjectID,
		arg.ProjectID_2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListRecentActivityRow{}
	for rows.Next() {
		var i ListRecentActivityRow
		if err := rows.Scan(
			&i.ActivityType,
			&i.ActivityID,
			&i.ProjectID,
			&i.Status,
			&i.CreatedAt,
			&i.ProjectName,
			&i.RequestedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRequestItems = `-- name: ListRequestItems :many
SELECT id, request_id, project_id, name, pkg, component_info, drawable, matched_icon_id, resolution, notes, created_at, updated_at FROM request_items WHERE request_id = ? ORDER BY created_at ASC
`

func (q *Queries) ListRequestItems(ctx context.Context, requestID uint64) ([]RequestItem, error) {
	rows, err := q.query(ctx, q.listRequestItemsStmt, listRequestItems, requestID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []RequestItem{}
	for rows.Next() {
		var i RequestItem
		if err := rows.Scan(
			&i.ID,
			&i.RequestID,
			&i.ProjectID,
			&i.Name,
			&i.Pkg,
			&i.ComponentInfo,
			&i.Drawable,
			&i.MatchedIconID,
			&i.Resolution,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRequestsByStatus = `-- name: ListRequestsByStatus :many
SELECT id, project_id, requested_by_user_id, source, apps_json, archive_path, status, message, created_at, updated_at FROM icon_requests WHERE project_id = ? AND status = ? ORDER BY created_at DESC LIMIT ? OFFSET ?
`

type ListRequestsByStatusParams struct {
	ProjectID uint64             `json:"project_id"`
	Status    IconRequestsStatus `json:"status"`
	Limit     int32              `json:"limit"`
	Offset    int32              `json:"offset"`
}

func (q *Queries) ListRequestsByStatus(ctx context.Context, arg ListRequestsByStatusParams) ([]IconRequest, error) {
	rows, err := q.query(ctx, q.listRequestsByStatusStmt, listRequestsByStatus,
		arg.ProjectID,
		arg.Status,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []IconRequest{}
	for rows.Next() {
		var i IconRequest
		if err := rows.Scan(
			&i.ID,
			&i.ProjectID,
			&i.RequestedByUserID,
			&i.Source,
			&i.AppsJson,
			&i.ArchivePath,
			&i.Status,
			&i.Message,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUserProjects = `-- name: ListUserProjects :many
SELECT upr.user_id, upr.project_id, upr.role, upr.added_at, p.name, p.slug, p.visibility, p.icon_count
FROM user_project_roles upr
JOIN projects p ON upr.project_id = p.id
WHERE upr.user_id = ?
ORDER BY upr.added_at DESC
`

type ListUserProjectsRow struct {
	UserID     uint64               `json:"user_id"`
	ProjectID  uint64               `json:"project_id"`
	Role       UserProjectRolesRole `json:"role"`
	AddedAt    time.Time            `json:"added_at"`
	Name       string               `json:"name"`
	Slug       string               `json:"slug"`
	Visibility ProjectsVisibility   `json:"visibility"`
	IconCount  uint32               `json:"icon_count"`
}

func (q *Queries) ListUserProjects(ctx context.Context, userID uint64) ([]ListUserProjectsRow, error) {
	rows, err := q.query(ctx, q.listUserProjectsStmt, listUserProjects, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListUserProjectsRow{}
	for rows.Next() {
		var i ListUserProjectsRow
		if err := rows.Scan(
			&i.UserID,
			&i.ProjectID,
			&i.Role,
			&i.AddedAt,
			&i.Name,
			&i.Slug,
			&i.Visibility,
			&i.IconCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchIcons = `-- name: SearchIcons :many
SELECT id, project_id, name, pkg, component_info, drawable, status, metadata, created_at, updated_at FROM icons 
WHERE project_id = ? 
  AND (name LIKE ? OR pkg LIKE ? OR component_info LIKE ?)
ORDER BY 
  CASE WHEN name LIKE ? THEN 1 
       WHEN pkg LIKE ? THEN 2 
       ELSE 3 END,
  created_at DESC
LIMIT ? OFFSET ?
`

type SearchIconsParams struct {
	ProjectID     uint64 `json:"project_id"`
	Name          string `json:"name"`
	Pkg           string `json:"pkg"`
	ComponentInfo string `json:"component_info"`
	Name_2        string `json:"name_2"`
	Pkg_2         string `json:"pkg_2"`
	Limit         int32  `json:"limit"`
	Offset        int32  `json:"offset"`
}

func (q *Queries) SearchIcons(ctx context.Context, arg SearchIconsParams) ([]Icon, error) {
	rows, err := q.query(ctx, q.searchIconsStmt, searchIcons,
		arg.ProjectID,
		arg.Name,
		arg.Pkg,
		arg.ComponentInfo,
		arg.Name_2,
		arg.Pkg_2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Icon{}
	for rows.Next() {
		var i Icon
		if err := rows.Scan(
			&i.ID,
			&i.ProjectID,
			&i.Name,
			&i.Pkg,
			&i.ComponentInfo,
			&i.Drawable,
			&i.Status,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateAPIKeyLastUsed = `-- name: UpdateAPIKeyLastUsed :exec
UPDATE project_api_keys SET 
  last_used_at = CURRENT_TIMESTAMP(6)
WHERE id = ?
`

func (q *Queries) UpdateAPIKeyLastUsed(ctx context.Context, id uint64) error {
	_, err := q.exec(ctx, q.updateAPIKeyLastUsedStmt, updateAPIKeyLastUsed, id)
	return err
}

const updateIcon = `-- name: UpdateIcon :exec
UPDATE icons SET 
  name = ?, 
  pkg = ?, 
  component_info = ?, 
  drawable = ?, 
  status = ?, 
  metadata = ?,
  updated_at = CURRENT_TIMESTAMP(6)
WHERE id = ? AND project_id = ?
`

type UpdateIconParams struct {
	Name          string         `json:"name"`
	Pkg           string         `json:"pkg"`
	ComponentInfo string         `json:"component_info"`
	Drawable      string         `json:"drawable"`
	Status        IconsStatus    `json:"status"`
	Metadata      sql.NullString `json:"metadata"`
	ID            uint64         `json:"id"`
	ProjectID     uint64         `json:"project_id"`
}

func (q *Queries) UpdateIcon(ctx context.Context, arg UpdateIconParams) error {
	_, err := q.exec(ctx, q.updateIconStmt, updateIcon,
		arg.Name,
		arg.Pkg,
		arg.ComponentInfo,
		arg.Drawable,
		arg.Status,
		arg.Metadata,
		arg.ID,
		arg.ProjectID,
	)
	return err
}

const updateIconStatus = `-- name: UpdateIconStatus :exec
UPDATE icons SET 
  status = ?,
  updated_at = CURRENT_TIMESTAMP(6)
WHERE id = ? AND project_id = ?
`

type UpdateIconStatusParams struct {
	Status    IconsStatus `json:"status"`
	ID        uint64      `json:"id"`
	ProjectID uint64      `json:"project_id"`
}

func (q *Queries) UpdateIconStatus(ctx context.Context, arg UpdateIconStatusParams) error {
	_, err := q.exec(ctx, q.updateIconStatusStmt, updateIconStatus, arg.Status, arg.ID, arg.ProjectID)
	return err
}

const updateItemResolution = `-- name: UpdateItemResolution :exec
UPDATE request_items SET 
  resolution = ?,
  matched_icon_id = ?,
  notes = ?,
  updated_at = CURRENT_TIMESTAMP(6)
WHERE id = ? AND request_id = ?
`

type UpdateItemResolutionParams struct {
	Resolution    RequestItemsResolution `json:"resolution"`
	MatchedIconID sql.NullInt64          `json:"matched_icon_id"`
	Notes         sql.NullString         `json:"notes"`
	ID            uint64                 `json:"id"`
	RequestID     uint64                 `json:"request_id"`
}

func (q *Queries) UpdateItemResolution(ctx context.Context, arg UpdateItemResolutionParams) error {
	_, err := q.exec(ctx, q.updateItemResolutionStmt, updateItemResolution,
		arg.Resolution,
		arg.MatchedIconID,
		arg.Notes,
		arg.ID,
		arg.RequestID,
	)
	return err
}

const updateProject = `-- name: UpdateProject :exec
UPDATE projects SET 
  name = ?, 
  slug = ?, 
  package_name = ?, 
  visibility = ?, 
  description = ?,
  updated_at = CURRENT_TIMESTAMP(6)
WHERE id = ? AND owner_user_id = ?
`

type UpdateProjectParams struct {
	Name        string             `json:"name"`
	Slug        string             `json:"slug"`
	PackageName sql.NullString     `json:"package_name"`
	Visibility  ProjectsVisibility `json:"visibility"`
	Description sql.NullString     `json:"description"`
	ID          uint64             `json:"id"`
	OwnerUserID uint64             `json:"owner_user_id"`
}

func (q *Queries) UpdateProject(ctx context.Context, arg UpdateProjectParams) error {
	_, err := q.exec(ctx, q.updateProjectStmt, updateProject,
		arg.Name,
		arg.Slug,
		arg.PackageName,
		arg.Visibility,
		arg.Description,
		arg.ID,
		arg.OwnerUserID,
	)
	return err
}

const updateProjectIconCount = `-- name: UpdateProjectIconCount :exec
UPDATE projects SET 
  icon_count = ?,
  updated_at = CURRENT_TIMESTAMP(6)
WHERE id = ?
`

type UpdateProjectIconCountParams struct {
	IconCount uint32 `json:"icon_count"`
	ID        uint64 `json:"id"`
}

func (q *Queries) UpdateProjectIconCount(ctx context.Context, arg UpdateProjectIconCountParams) error {
	_, err := q.exec(ctx, q.updateProjectIconCountStmt, updateProjectIconCount, arg.IconCount, arg.ID)
	return err
}

const updateRequestArchivePath = `-- name: UpdateRequestArchivePath :exec
UPDATE icon_requests SET 
  archive_path = ?,
  updated_at = CURRENT_TIMESTAMP(6)
WHERE id = ? AND project_id = ?
`

type UpdateRequestArchivePathParams struct {
	ArchivePath sql.NullString `json:"archive_path"`
	ID          uint64         `json:"id"`
	ProjectID   uint64         `json:"project_id"`
}

func (q *Queries) UpdateRequestArchivePath(ctx context.Context, arg UpdateRequestArchivePathParams) error {
	_, err := q.exec(ctx, q.updateRequestArchivePathStmt, updateRequestArchivePath, arg.ArchivePath, arg.ID, arg.ProjectID)
	return err
}

const updateRequestItem = `-- name: UpdateRequestItem :exec
UPDATE request_items SET 
  name = ?, 
  pkg = ?, 
  component_info = ?, 
  drawable = ?, 
  matched_icon_id = ?, 
  resolution = ?, 
  notes = ?,
  updated_at = CURRENT_TIMESTAMP(6)
WHERE id = ? AND request_id = ?
`

type UpdateRequestItemParams struct {
	Name          string                 `json:"name"`
	Pkg           string                 `json:"pkg"`
	ComponentInfo string                 `json:"component_info"`
	Drawable      string                 `json:"drawable"`
	MatchedIconID sql.NullInt64          `json:"matched_icon_id"`
	Resolution    RequestItemsResolution `json:"resolution"`
	Notes         sql.NullString         `json:"notes"`
	ID            uint64                 `json:"id"`
	RequestID     uint64                 `json:"request_id"`
}

func (q *Queries) UpdateRequestItem(ctx context.Context, arg UpdateRequestItemParams) error {
	_, err := q.exec(ctx, q.updateRequestItemStmt, updateRequestItem,
		arg.Name,
		arg.Pkg,
		arg.ComponentInfo,
		arg.Drawable,
		arg.MatchedIconID,
		arg.Resolution,
		arg.Notes,
		arg.ID,
		arg.RequestID,
	)
	return err
}

const updateRequestStatus = `-- name: UpdateRequestStatus :exec
UPDATE icon_requests SET 
  status = ?,
  message = ?,
  updated_at = CURRENT_TIMESTAMP(6)
WHERE id = ? AND project_id = ?
`

type UpdateRequestStatusParams struct {
	Status    IconRequestsStatus `json:"status"`
	Message   sql.NullString     `json:"message"`
	ID        uint64             `json:"id"`
	ProjectID uint64             `json:"project_id"`
}

func (q *Queries) UpdateRequestStatus(ctx context.Context, arg UpdateRequestStatusParams) error {
	_, err := q.exec(ctx, q.updateRequestStatusStmt, updateRequestStatus,
		arg.Status,
		arg.Message,
		arg.ID,
		arg.ProjectID,
	)
	return err
}

const updateUserProjectRole = `-- name: UpdateUserProjectRole :exec
UPDATE user_project_roles SET role = ? WHERE user_id = ? AND project_id = ?
`

type UpdateUserProjectRoleParams struct {
	Role      UserProjectRolesRole `json:"role"`
	UserID    uint64               `json:"user_id"`
	ProjectID uint64               `json:"project_id"`
}

func (q *Queries) UpdateUserProjectRole(ctx context.Context, arg UpdateUserProjectRoleParams) error {
	_, err := q.exec(ctx, q.updateUserProjectRoleStmt, updateUserProjectRole, arg.Role, arg.UserID, arg.ProjectID)
	return err
}

const updateUserQuota = `-- name: UpdateUserQuota :exec
UPDATE user_quotas SET 
  max_projects = ?
WHERE user_id = ?
`

type UpdateUserQuotaParams struct {
	MaxProjects uint32 `json:"max_projects"`
	UserID      uint64 `json:"user_id"`
}

func (q *Queries) UpdateUserQuota(ctx context.Context, arg UpdateUserQuotaParams) error {
	_, err := q.exec(ctx, q.updateUserQuotaStmt, updateUserQuota, arg.MaxProjects, arg.UserID)
	return err
}
