// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: account.sql

package account

import (
	"context"
	"database/sql"
)

const countUsers = `-- name: CountUsers :one
SELECT COUNT(*) FROM users WHERE status != 4
`

func (q *Queries) CountUsers(ctx context.Context) (int64, error) {
	row := q.queryRow(ctx, q.countUsersStmt, countUsers)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countUsersByStatus = `-- name: CountUsersByStatus :one
SELECT COUNT(*) FROM users WHERE status = ?
`

func (q *Queries) CountUsersByStatus(ctx context.Context, status bool) (int64, error) {
	row := q.queryRow(ctx, q.countUsersByStatusStmt, countUsersByStatus, status)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createUser = `-- name: CreateUser :execresult
INSERT INTO users (
  username, email, password_hash, display_name, phone, locale, timezone
) VALUES (?, ?, ?, ?, ?, ?, ?)
`

type CreateUserParams struct {
	Username     string         `json:"username"`
	Email        string         `json:"email"`
	PasswordHash string         `json:"password_hash"`
	DisplayName  sql.NullString `json:"display_name"`
	Phone        sql.NullString `json:"phone"`
	Locale       string         `json:"locale"`
	Timezone     string         `json:"timezone"`
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (sql.Result, error) {
	return q.exec(ctx, q.createUserStmt, createUser,
		arg.Username,
		arg.Email,
		arg.PasswordHash,
		arg.DisplayName,
		arg.Phone,
		arg.Locale,
		arg.Timezone,
	)
}

const deleteUser = `-- name: DeleteUser :exec
UPDATE users SET 
  status = 4,
  updated_at = CURRENT_TIMESTAMP(6)
WHERE id = ?
`

func (q *Queries) DeleteUser(ctx context.Context, id uint64) error {
	_, err := q.exec(ctx, q.deleteUserStmt, deleteUser, id)
	return err
}

const getLockedUsers = `-- name: GetLockedUsers :many
SELECT id, username, email, password_hash, status, created_at, updated_at, last_login_at, failed_attempts, locked_until, email_verified_at, password_changed_at, display_name, avatar_url, phone, locale, timezone, mfa_enabled, mfa_secret, recovery_codes, privacy_version, marketing_consent FROM users WHERE status = 3 AND locked_until IS NOT NULL ORDER BY locked_until ASC
`

func (q *Queries) GetLockedUsers(ctx context.Context) ([]User, error) {
	rows, err := q.query(ctx, q.getLockedUsersStmt, getLockedUsers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []User{}
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.Email,
			&i.PasswordHash,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.LastLoginAt,
			&i.FailedAttempts,
			&i.LockedUntil,
			&i.EmailVerifiedAt,
			&i.PasswordChangedAt,
			&i.DisplayName,
			&i.AvatarUrl,
			&i.Phone,
			&i.Locale,
			&i.Timezone,
			&i.MfaEnabled,
			&i.MfaSecret,
			&i.RecoveryCodes,
			&i.PrivacyVersion,
			&i.MarketingConsent,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT id, username, email, password_hash, status, created_at, updated_at, last_login_at, failed_attempts, locked_until, email_verified_at, password_changed_at, display_name, avatar_url, phone, locale, timezone, mfa_enabled, mfa_secret, recovery_codes, privacy_version, marketing_consent FROM users WHERE email = ? AND status != 4 LIMIT 1
`

func (q *Queries) GetUserByEmail(ctx context.Context, email string) (User, error) {
	row := q.queryRow(ctx, q.getUserByEmailStmt, getUserByEmail, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.PasswordHash,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastLoginAt,
		&i.FailedAttempts,
		&i.LockedUntil,
		&i.EmailVerifiedAt,
		&i.PasswordChangedAt,
		&i.DisplayName,
		&i.AvatarUrl,
		&i.Phone,
		&i.Locale,
		&i.Timezone,
		&i.MfaEnabled,
		&i.MfaSecret,
		&i.RecoveryCodes,
		&i.PrivacyVersion,
		&i.MarketingConsent,
	)
	return i, err
}

const getUserByID = `-- name: GetUserByID :one
SELECT id, username, email, password_hash, status, created_at, updated_at, last_login_at, failed_attempts, locked_until, email_verified_at, password_changed_at, display_name, avatar_url, phone, locale, timezone, mfa_enabled, mfa_secret, recovery_codes, privacy_version, marketing_consent FROM users WHERE id = ? AND status != 4 LIMIT 1
`

func (q *Queries) GetUserByID(ctx context.Context, id uint64) (User, error) {
	row := q.queryRow(ctx, q.getUserByIDStmt, getUserByID, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.PasswordHash,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastLoginAt,
		&i.FailedAttempts,
		&i.LockedUntil,
		&i.EmailVerifiedAt,
		&i.PasswordChangedAt,
		&i.DisplayName,
		&i.AvatarUrl,
		&i.Phone,
		&i.Locale,
		&i.Timezone,
		&i.MfaEnabled,
		&i.MfaSecret,
		&i.RecoveryCodes,
		&i.PrivacyVersion,
		&i.MarketingConsent,
	)
	return i, err
}

const getUserByPhone = `-- name: GetUserByPhone :one
SELECT id, username, email, password_hash, status, created_at, updated_at, last_login_at, failed_attempts, locked_until, email_verified_at, password_changed_at, display_name, avatar_url, phone, locale, timezone, mfa_enabled, mfa_secret, recovery_codes, privacy_version, marketing_consent FROM users WHERE phone = ? AND status != 4 LIMIT 1
`

func (q *Queries) GetUserByPhone(ctx context.Context, phone sql.NullString) (User, error) {
	row := q.queryRow(ctx, q.getUserByPhoneStmt, getUserByPhone, phone)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.PasswordHash,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastLoginAt,
		&i.FailedAttempts,
		&i.LockedUntil,
		&i.EmailVerifiedAt,
		&i.PasswordChangedAt,
		&i.DisplayName,
		&i.AvatarUrl,
		&i.Phone,
		&i.Locale,
		&i.Timezone,
		&i.MfaEnabled,
		&i.MfaSecret,
		&i.RecoveryCodes,
		&i.PrivacyVersion,
		&i.MarketingConsent,
	)
	return i, err
}

const getUserByUsername = `-- name: GetUserByUsername :one
SELECT id, username, email, password_hash, status, created_at, updated_at, last_login_at, failed_attempts, locked_until, email_verified_at, password_changed_at, display_name, avatar_url, phone, locale, timezone, mfa_enabled, mfa_secret, recovery_codes, privacy_version, marketing_consent FROM users WHERE username = ? AND status != 4 LIMIT 1
`

func (q *Queries) GetUserByUsername(ctx context.Context, username string) (User, error) {
	row := q.queryRow(ctx, q.getUserByUsernameStmt, getUserByUsername, username)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.PasswordHash,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastLoginAt,
		&i.FailedAttempts,
		&i.LockedUntil,
		&i.EmailVerifiedAt,
		&i.PasswordChangedAt,
		&i.DisplayName,
		&i.AvatarUrl,
		&i.Phone,
		&i.Locale,
		&i.Timezone,
		&i.MfaEnabled,
		&i.MfaSecret,
		&i.RecoveryCodes,
		&i.PrivacyVersion,
		&i.MarketingConsent,
	)
	return i, err
}

const getUsersByEmailVerified = `-- name: GetUsersByEmailVerified :many
SELECT id, username, email, password_hash, status, created_at, updated_at, last_login_at, failed_attempts, locked_until, email_verified_at, password_changed_at, display_name, avatar_url, phone, locale, timezone, mfa_enabled, mfa_secret, recovery_codes, privacy_version, marketing_consent FROM users WHERE email_verified_at IS NOT NULL AND status != 4 ORDER BY created_at DESC
`

func (q *Queries) GetUsersByEmailVerified(ctx context.Context) ([]User, error) {
	rows, err := q.query(ctx, q.getUsersByEmailVerifiedStmt, getUsersByEmailVerified)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []User{}
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.Email,
			&i.PasswordHash,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.LastLoginAt,
			&i.FailedAttempts,
			&i.LockedUntil,
			&i.EmailVerifiedAt,
			&i.PasswordChangedAt,
			&i.DisplayName,
			&i.AvatarUrl,
			&i.Phone,
			&i.Locale,
			&i.Timezone,
			&i.MfaEnabled,
			&i.MfaSecret,
			&i.RecoveryCodes,
			&i.PrivacyVersion,
			&i.MarketingConsent,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUsersByLastLogin = `-- name: GetUsersByLastLogin :many
SELECT id, username, email, password_hash, status, created_at, updated_at, last_login_at, failed_attempts, locked_until, email_verified_at, password_changed_at, display_name, avatar_url, phone, locale, timezone, mfa_enabled, mfa_secret, recovery_codes, privacy_version, marketing_consent FROM users WHERE last_login_at IS NOT NULL AND status != 4 ORDER BY last_login_at DESC LIMIT ? OFFSET ?
`

type GetUsersByLastLoginParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) GetUsersByLastLogin(ctx context.Context, arg GetUsersByLastLoginParams) ([]User, error) {
	rows, err := q.query(ctx, q.getUsersByLastLoginStmt, getUsersByLastLogin, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []User{}
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.Email,
			&i.PasswordHash,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.LastLoginAt,
			&i.FailedAttempts,
			&i.LockedUntil,
			&i.EmailVerifiedAt,
			&i.PasswordChangedAt,
			&i.DisplayName,
			&i.AvatarUrl,
			&i.Phone,
			&i.Locale,
			&i.Timezone,
			&i.MfaEnabled,
			&i.MfaSecret,
			&i.RecoveryCodes,
			&i.PrivacyVersion,
			&i.MarketingConsent,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUsersWithMFA = `-- name: GetUsersWithMFA :many
SELECT id, username, email, password_hash, status, created_at, updated_at, last_login_at, failed_attempts, locked_until, email_verified_at, password_changed_at, display_name, avatar_url, phone, locale, timezone, mfa_enabled, mfa_secret, recovery_codes, privacy_version, marketing_consent FROM users WHERE mfa_enabled = TRUE AND status != 4 ORDER BY created_at DESC
`

func (q *Queries) GetUsersWithMFA(ctx context.Context) ([]User, error) {
	rows, err := q.query(ctx, q.getUsersWithMFAStmt, getUsersWithMFA)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []User{}
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.Email,
			&i.PasswordHash,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.LastLoginAt,
			&i.FailedAttempts,
			&i.LockedUntil,
			&i.EmailVerifiedAt,
			&i.PasswordChangedAt,
			&i.DisplayName,
			&i.AvatarUrl,
			&i.Phone,
			&i.Locale,
			&i.Timezone,
			&i.MfaEnabled,
			&i.MfaSecret,
			&i.RecoveryCodes,
			&i.PrivacyVersion,
			&i.MarketingConsent,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const incrementFailedAttempts = `-- name: IncrementFailedAttempts :exec
UPDATE users SET 
  failed_attempts = failed_attempts + 1,
  updated_at = CURRENT_TIMESTAMP(6)
WHERE id = ?
`

func (q *Queries) IncrementFailedAttempts(ctx context.Context, id uint64) error {
	_, err := q.exec(ctx, q.incrementFailedAttemptsStmt, incrementFailedAttempts, id)
	return err
}

const listUsers = `-- name: ListUsers :many
SELECT id, username, email, password_hash, status, created_at, updated_at, last_login_at, failed_attempts, locked_until, email_verified_at, password_changed_at, display_name, avatar_url, phone, locale, timezone, mfa_enabled, mfa_secret, recovery_codes, privacy_version, marketing_consent FROM users WHERE status != 4 ORDER BY created_at DESC LIMIT ? OFFSET ?
`

type ListUsersParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListUsers(ctx context.Context, arg ListUsersParams) ([]User, error) {
	rows, err := q.query(ctx, q.listUsersStmt, listUsers, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []User{}
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.Email,
			&i.PasswordHash,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.LastLoginAt,
			&i.FailedAttempts,
			&i.LockedUntil,
			&i.EmailVerifiedAt,
			&i.PasswordChangedAt,
			&i.DisplayName,
			&i.AvatarUrl,
			&i.Phone,
			&i.Locale,
			&i.Timezone,
			&i.MfaEnabled,
			&i.MfaSecret,
			&i.RecoveryCodes,
			&i.PrivacyVersion,
			&i.MarketingConsent,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUsersByStatus = `-- name: ListUsersByStatus :many
SELECT id, username, email, password_hash, status, created_at, updated_at, last_login_at, failed_attempts, locked_until, email_verified_at, password_changed_at, display_name, avatar_url, phone, locale, timezone, mfa_enabled, mfa_secret, recovery_codes, privacy_version, marketing_consent FROM users WHERE status = ? ORDER BY created_at DESC LIMIT ? OFFSET ?
`

type ListUsersByStatusParams struct {
	Status bool  `json:"status"`
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListUsersByStatus(ctx context.Context, arg ListUsersByStatusParams) ([]User, error) {
	rows, err := q.query(ctx, q.listUsersByStatusStmt, listUsersByStatus, arg.Status, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []User{}
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.Email,
			&i.PasswordHash,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.LastLoginAt,
			&i.FailedAttempts,
			&i.LockedUntil,
			&i.EmailVerifiedAt,
			&i.PasswordChangedAt,
			&i.DisplayName,
			&i.AvatarUrl,
			&i.Phone,
			&i.Locale,
			&i.Timezone,
			&i.MfaEnabled,
			&i.MfaSecret,
			&i.RecoveryCodes,
			&i.PrivacyVersion,
			&i.MarketingConsent,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const lockUser = `-- name: LockUser :exec
UPDATE users SET 
  status = 3,
  locked_until = ?,
  updated_at = CURRENT_TIMESTAMP(6)
WHERE id = ?
`

type LockUserParams struct {
	LockedUntil sql.NullTime `json:"locked_until"`
	ID          uint64       `json:"id"`
}

func (q *Queries) LockUser(ctx context.Context, arg LockUserParams) error {
	_, err := q.exec(ctx, q.lockUserStmt, lockUser, arg.LockedUntil, arg.ID)
	return err
}

const unlockUser = `-- name: UnlockUser :exec
UPDATE users SET 
  status = 1,
  locked_until = NULL,
  failed_attempts = 0,
  updated_at = CURRENT_TIMESTAMP(6)
WHERE id = ?
`

func (q *Queries) UnlockUser(ctx context.Context, id uint64) error {
	_, err := q.exec(ctx, q.unlockUserStmt, unlockUser, id)
	return err
}

const updateLastLogin = `-- name: UpdateLastLogin :exec
UPDATE users SET 
  last_login_at = CURRENT_TIMESTAMP(6),
  failed_attempts = 0,
  locked_until = NULL,
  updated_at = CURRENT_TIMESTAMP(6)
WHERE id = ?
`

func (q *Queries) UpdateLastLogin(ctx context.Context, id uint64) error {
	_, err := q.exec(ctx, q.updateLastLoginStmt, updateLastLogin, id)
	return err
}

const updateMFASettings = `-- name: UpdateMFASettings :exec
UPDATE users SET 
  mfa_enabled = ?,
  mfa_secret = ?,
  recovery_codes = ?,
  updated_at = CURRENT_TIMESTAMP(6)
WHERE id = ?
`

type UpdateMFASettingsParams struct {
	MfaEnabled    bool           `json:"mfa_enabled"`
	MfaSecret     sql.NullString `json:"mfa_secret"`
	RecoveryCodes sql.NullString `json:"recovery_codes"`
	ID            uint64         `json:"id"`
}

func (q *Queries) UpdateMFASettings(ctx context.Context, arg UpdateMFASettingsParams) error {
	_, err := q.exec(ctx, q.updateMFASettingsStmt, updateMFASettings,
		arg.MfaEnabled,
		arg.MfaSecret,
		arg.RecoveryCodes,
		arg.ID,
	)
	return err
}

const updateMarketingConsent = `-- name: UpdateMarketingConsent :exec
UPDATE users SET 
  marketing_consent = ?,
  updated_at = CURRENT_TIMESTAMP(6)
WHERE id = ?
`

type UpdateMarketingConsentParams struct {
	MarketingConsent bool   `json:"marketing_consent"`
	ID               uint64 `json:"id"`
}

func (q *Queries) UpdateMarketingConsent(ctx context.Context, arg UpdateMarketingConsentParams) error {
	_, err := q.exec(ctx, q.updateMarketingConsentStmt, updateMarketingConsent, arg.MarketingConsent, arg.ID)
	return err
}

const updatePrivacyVersion = `-- name: UpdatePrivacyVersion :exec
UPDATE users SET 
  privacy_version = ?,
  updated_at = CURRENT_TIMESTAMP(6)
WHERE id = ?
`

type UpdatePrivacyVersionParams struct {
	PrivacyVersion uint16 `json:"privacy_version"`
	ID             uint64 `json:"id"`
}

func (q *Queries) UpdatePrivacyVersion(ctx context.Context, arg UpdatePrivacyVersionParams) error {
	_, err := q.exec(ctx, q.updatePrivacyVersionStmt, updatePrivacyVersion, arg.PrivacyVersion, arg.ID)
	return err
}

const updateUserPassword = `-- name: UpdateUserPassword :exec
UPDATE users SET 
  password_hash = ?, 
  password_changed_at = CURRENT_TIMESTAMP(6),
  updated_at = CURRENT_TIMESTAMP(6)
WHERE id = ?
`

type UpdateUserPasswordParams struct {
	PasswordHash string `json:"password_hash"`
	ID           uint64 `json:"id"`
}

func (q *Queries) UpdateUserPassword(ctx context.Context, arg UpdateUserPasswordParams) error {
	_, err := q.exec(ctx, q.updateUserPasswordStmt, updateUserPassword, arg.PasswordHash, arg.ID)
	return err
}

const updateUserProfile = `-- name: UpdateUserProfile :exec
UPDATE users SET 
  display_name = ?, 
  avatar_url = ?, 
  phone = ?, 
  locale = ?, 
  timezone = ?,
  updated_at = CURRENT_TIMESTAMP(6)
WHERE id = ?
`

type UpdateUserProfileParams struct {
	DisplayName sql.NullString `json:"display_name"`
	AvatarUrl   sql.NullString `json:"avatar_url"`
	Phone       sql.NullString `json:"phone"`
	Locale      string         `json:"locale"`
	Timezone    string         `json:"timezone"`
	ID          uint64         `json:"id"`
}

func (q *Queries) UpdateUserProfile(ctx context.Context, arg UpdateUserProfileParams) error {
	_, err := q.exec(ctx, q.updateUserProfileStmt, updateUserProfile,
		arg.DisplayName,
		arg.AvatarUrl,
		arg.Phone,
		arg.Locale,
		arg.Timezone,
		arg.ID,
	)
	return err
}

const updateUserStatus = `-- name: UpdateUserStatus :exec
UPDATE users SET 
  status = ?, 
  updated_at = CURRENT_TIMESTAMP(6)
WHERE id = ?
`

type UpdateUserStatusParams struct {
	Status bool   `json:"status"`
	ID     uint64 `json:"id"`
}

func (q *Queries) UpdateUserStatus(ctx context.Context, arg UpdateUserStatusParams) error {
	_, err := q.exec(ctx, q.updateUserStatusStmt, updateUserStatus, arg.Status, arg.ID)
	return err
}

const verifyEmail = `-- name: VerifyEmail :exec
UPDATE users SET 
  email_verified_at = CURRENT_TIMESTAMP(6),
  updated_at = CURRENT_TIMESTAMP(6)
WHERE id = ?
`

func (q *Queries) VerifyEmail(ctx context.Context, id uint64) error {
	_, err := q.exec(ctx, q.verifyEmailStmt, verifyEmail, id)
	return err
}
