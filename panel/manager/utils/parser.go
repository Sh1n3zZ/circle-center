package utils

import (
	"bytes"
	"fmt"
	"strings"

	"github.com/beevik/etree"
)

// IconRequestComponent represents a single requested app icon mapping.
// Fields are designed to round-trip between JSON payload and XML files.
// - Name is optional in XML formats (kept for parity with JSON side).
// - Package can be inferred from ComponentInfo when available.
type IconRequestComponent struct {
	Name          string `json:"name"`
	Package       string `json:"pkg"`
	ComponentInfo string `json:"componentInfo"`
	Drawable      string `json:"drawable"`
}

// BuildAppFilterXML builds the appfilter XML as generated by the Android packer.
// It includes iconback/iconmask/iconupon/scale and a list of <item> entries like:
// <item component="ComponentInfo{<component>}" drawable="<drawable>"/>
func BuildAppFilterXML(appName string, components []IconRequestComponent) (string, error) {
	doc := etree.NewDocument()
	resources := doc.CreateElement("resources")

	// Static header entries to match the Android generator
	iconback := resources.CreateElement("iconback")
	iconback.CreateAttr("img1", "iconback")
	iconmask := resources.CreateElement("iconmask")
	iconmask.CreateAttr("img1", "iconmask")
	iconupon := resources.CreateElement("iconupon")
	iconupon.CreateAttr("img1", "iconupon")
	scale := resources.CreateElement("scale")
	scale.CreateAttr("factor", "1.0")

	for _, c := range components {
		if strings.TrimSpace(c.Drawable) == "" || strings.TrimSpace(c.ComponentInfo) == "" {
			continue
		}
		if strings.TrimSpace(c.Name) != "" {
			// <!-- App Name -->
			resources.CreateComment(" " + c.Name + " ")
		}
		item := resources.CreateElement("item")
		item.CreateAttr("component", fmt.Sprintf("ComponentInfo{%s}", c.ComponentInfo))
		item.CreateAttr("drawable", c.Drawable)
	}

	var buf bytes.Buffer
	doc.Indent(1)
	if _, err := doc.WriteTo(&buf); err != nil {
		return "", err
	}
	return buf.String(), nil
}

// BuildAppMapXML builds the appmap XML with entries like:
// <item class="<class>" name="<drawable>"/>
// The class attribute is extracted from ComponentInfo's right-side part after '/'.
func BuildAppMapXML(appName string, components []IconRequestComponent) (string, error) {
	doc := etree.NewDocument()
	root := doc.CreateElement("appmap")

	for _, c := range components {
		drawable := strings.TrimSpace(c.Drawable)
		comp := strings.TrimSpace(c.ComponentInfo)
		if drawable == "" || comp == "" {
			continue
		}
		classRight := ExtractRightClassFromComponent(comp)
		if strings.TrimSpace(c.Name) != "" {
			root.CreateComment(" " + c.Name + " ")
		}
		item := root.CreateElement("item")
		item.CreateAttr("class", classRight)
		item.CreateAttr("name", drawable)
	}

	var buf bytes.Buffer
	doc.Indent(1)
	if _, err := doc.WriteTo(&buf); err != nil {
		return "", err
	}
	return buf.String(), nil
}

// BuildThemeResourcesXML builds theme_resources XML with entries like:
// <AppIcon name="<component>" image="<drawable>"/>
func BuildThemeResourcesXML(appName string, components []IconRequestComponent) (string, error) {
	doc := etree.NewDocument()
	root := doc.CreateElement("Theme")
	root.CreateAttr("version", "1")

	// Fixed header to mimic Android builder output
	label := root.CreateElement("Label")
	label.CreateAttr("value", strings.TrimSpace(appName))
	wallpaper := root.CreateElement("Wallpaper")
	wallpaper.CreateAttr("image", "wallpaper_01")
	lsw := root.CreateElement("LockScreenWallpaper")
	lsw.CreateAttr("image", "wallpaper_02")
	tp := root.CreateElement("ThemePreview")
	tp.CreateAttr("image", "preview1")
	tpw := root.CreateElement("ThemePreviewWork")
	tpw.CreateAttr("image", "preview1")
	tpm := root.CreateElement("ThemePreviewMenu")
	tpm.CreateAttr("image", "preview1")
	dmai := root.CreateElement("DockMenuAppIcon")
	dmai.CreateAttr("selector", "drawer")

	for _, c := range components {
		drawable := strings.TrimSpace(c.Drawable)
		comp := strings.TrimSpace(c.ComponentInfo)
		if drawable == "" || comp == "" {
			continue
		}
		if strings.TrimSpace(c.Name) != "" {
			root.CreateComment(" " + c.Name + " ")
		}
		appIcon := root.CreateElement("AppIcon")
		appIcon.CreateAttr("name", comp)
		appIcon.CreateAttr("image", drawable)
	}

	var buf bytes.Buffer
	doc.Indent(1)
	if _, err := doc.WriteTo(&buf); err != nil {
		return "", err
	}
	return buf.String(), nil
}

// ParseAppFilterXML parses an appfilter XML string and returns components
// with ComponentInfo and Drawable filled.
func ParseAppFilterXML(xmlStr string) ([]IconRequestComponent, error) {
	doc := etree.NewDocument()
	if err := doc.ReadFromString(xmlStr); err != nil {
		return nil, err
	}
	root := doc.SelectElement("resources")
	if root == nil {
		return nil, fmt.Errorf("invalid appfilter xml: missing <resources>")
	}
	var out []IconRequestComponent
	for _, el := range root.SelectElements("item") {
		compAttr := strings.TrimSpace(el.SelectAttrValue("component", ""))
		drawable := strings.TrimSpace(el.SelectAttrValue("drawable", ""))
		if drawable == "" || compAttr == "" {
			continue
		}
		comp := TrimComponentInfoWrapper(compAttr)
		out = append(out, IconRequestComponent{ComponentInfo: comp, Drawable: drawable})
	}
	return out, nil
}

// ParseAppMapXML parses an appmap XML and returns pairs of (classRight, drawableName).
// Returned as IconRequestComponent with Drawable set and ComponentInfo empty,
// because this file alone does not contain the full ComponentInfo.
func ParseAppMapXML(xmlStr string) ([]IconRequestComponent, error) {
	doc := etree.NewDocument()
	if err := doc.ReadFromString(xmlStr); err != nil {
		return nil, err
	}
	root := doc.SelectElement("appmap")
	if root == nil {
		return nil, fmt.Errorf("invalid appmap xml: missing <appmap>")
	}
	var out []IconRequestComponent
	for _, el := range root.SelectElements("item") {
		classRight := strings.TrimSpace(el.SelectAttrValue("class", ""))
		drawable := strings.TrimSpace(el.SelectAttrValue("name", ""))
		if drawable == "" {
			continue
		}
		// Store classRight in Package field temporarily for potential merge hints.
		out = append(out, IconRequestComponent{Package: classRight, Drawable: drawable})
	}
	return out, nil
}

// ParseThemeResourcesXML parses theme_resources XML and returns pairs
// of (componentInfo, drawable).
func ParseThemeResourcesXML(xmlStr string) ([]IconRequestComponent, error) {
	doc := etree.NewDocument()
	if err := doc.ReadFromString(xmlStr); err != nil {
		return nil, err
	}
	root := doc.SelectElement("Theme")
	if root == nil {
		return nil, fmt.Errorf("invalid theme_resources xml: missing <Theme>")
	}
	var out []IconRequestComponent
	for _, el := range root.SelectElements("AppIcon") {
		comp := strings.TrimSpace(el.SelectAttrValue("name", ""))
		drawable := strings.TrimSpace(el.SelectAttrValue("image", ""))
		if drawable == "" || comp == "" {
			continue
		}
		out = append(out, IconRequestComponent{ComponentInfo: comp, Drawable: drawable})
	}
	return out, nil
}

// MergeParsedComponents merges components while allowing multiple entries per drawable.
// De-duplication key is (componentInfo, drawable). This preserves cases where the same
// drawable name maps to multiple components.
// Name is preserved if any input provided it (rare in XML). Package is inferred from ComponentInfo.
func MergeParsedComponents(appfilter, appmap, theme []IconRequestComponent) []IconRequestComponent {
	// Key by componentInfo + drawable; lowercased and trimmed for stability
	keyOf := func(ci, dr string) string {
		return strings.ToLower(strings.TrimSpace(ci)) + "||" + strings.ToLower(strings.TrimSpace(dr))
	}

	byKey := map[string]IconRequestComponent{}

	// Seed with theme (richest info in many packs)
	for _, c := range theme {
		drawable := strings.TrimSpace(c.Drawable)
		comp := strings.TrimSpace(c.ComponentInfo)
		if drawable == "" || comp == "" {
			continue
		}
		c.Package = InferPackageFromComponent(comp)
		byKey[keyOf(comp, drawable)] = c
	}

	// Merge appfilter
	for _, c := range appfilter {
		drawable := strings.TrimSpace(c.Drawable)
		comp := strings.TrimSpace(c.ComponentInfo)
		if drawable == "" || comp == "" {
			continue
		}
		k := keyOf(comp, drawable)
		if existing, ok := byKey[k]; ok {
			// Prefer non-empty fields
			if existing.Name == "" && c.Name != "" {
				existing.Name = c.Name
			}
			if existing.Package == "" {
				existing.Package = InferPackageFromComponent(existing.ComponentInfo)
			}
			byKey[k] = existing
		} else {
			c.Package = InferPackageFromComponent(comp)
			byKey[k] = c
		}
	}

	// appmap entries only contain classRight and drawable; lacking componentInfo makes it
	// impossible to build a reliable key. We skip creating separate rows from appmap to avoid
	// noisy duplicates. Future enhancement could try to align by drawable heuristically.

	// Flatten
	out := make([]IconRequestComponent, 0, len(byKey))
	for _, v := range byKey {
		out = append(out, v)
	}
	return out
}

// TrimComponentInfoWrapper removes optional ComponentInfo{...} wrapper
// and returns the inner component string.
func TrimComponentInfoWrapper(componentAttr string) string {
	s := strings.TrimSpace(componentAttr)
	if strings.HasPrefix(s, "ComponentInfo{") && strings.HasSuffix(s, "}") {
		return strings.TrimSuffix(strings.TrimPrefix(s, "ComponentInfo{"), "}")
	}
	return s
}

// ExtractRightClassFromComponent returns the right-hand part after '/' in a component string.
// Examples:
// - com.pkg/.MainActivity -> .MainActivity
// - com.pkg/com.pkg.MainActivity -> com.pkg.MainActivity
func ExtractRightClassFromComponent(component string) string {
	s := strings.TrimSpace(component)
	if s == "" {
		return ""
	}
	parts := strings.Split(s, "/")
	if len(parts) < 2 {
		return s
	}
	return parts[1]
}

// InferPackageFromComponent attempts to extract the package name from a component string.
// Examples:
// - com.pkg/.MainActivity -> com.pkg
// - com.pkg/com.pkg.MainActivity -> com.pkg
func InferPackageFromComponent(component string) string {
	s := strings.TrimSpace(component)
	if s == "" {
		return ""
	}
	parts := strings.Split(s, "/")
	if len(parts) == 0 {
		return ""
	}
	return strings.TrimSpace(parts[0])
}
